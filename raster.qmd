# Raster data

As geoscientists, it is very likely that the majority of data we work with is in raster format.
In this section, we will look at how to read raster data into R, how to perform raster/vector operations and basic usage of data cubes.

We need the packages below, where `stars` [@R-stars] and `terra` [@R-terra] are the workforces to handle raster datasets in R.

We load `sf` for raster/vector interaction, `ggplot2`, `tmap` and `units` for visualisation.

```{r}
#| label: libraries
#| warning: false
library(sf)       # vector spatial data classes and functions
library(terra)    # raster spatial data classes and functions
library(tmap)     # noninteractive and interactive maps
library(stars)    # spatiotemporal arrays classes and functions
library(ggplot2)  # non-spatial and spatial plotting
library(units)    # units conversions
```

## Raster-vector operations

We use here datasets from the `spDataLarge` package. 
Similar to `spData` this is a data package.
The data consists of terrain derivatives and a set of landslide locations in Ecuador.
The data is used for landslide susceptibility assessment.

We call two vector datasets, `lsl` and `study_mask` first.
We convert `lsl` into an sf object with `sf::st_as_sf()`.

```{r}
data("lsl", "study_mask", package = "spDataLarge")
landslides = st_as_sf(
  lsl,
  coords = c("x", "y"), 
  crs = "EPSG:32717"
)
```

As for the raster data, we use `terra::rast()` in this case. 
We call the data from its location on file for this using `system.file()`.

```{r}
terrain = rast(system.file("raster/ta.tif", package = "spDataLarge"))
terrain
```

### Masking 

Now, the first operation we apply to this raster data is a mask. 
We use the `study_mask` object we loaded above to crop our data to a polygon.

```{r}
terrain = mask(terrain, study_mask)
```

Let's take a first glance of our data using `tmap`.
Here we plot the terrain derivatives and the landslide points in separate subplots.

```{r}
#| warning: false
#| message: false
#| fig-width: 15
#| fig-height: 4.5
#| fig-column: page
tm_shape(terrain) +
  tm_raster(
    col.scale = tm_scale_continuous(midpoint = NA),
    col.legend = tm_legend(orientation = "landscape")
  ) +
  tm_facets_hstack() +
  tm_shape(landslides) +
  tm_dots() 
```


### Extraction

Another common operation is to extract raster values at point locations. 
We can easily do this using `terra::extract()`.

```{r}
head(terra::extract(terrain, landslides))
```

We did not save the result of this since the landslides object already has the corresponding columns.

```{r}
landslides
```

### Predictions

Once we have extracted the data from the terrain derivatives at the landslide point locations, 
we can proceed to create a generalized linear model (GLM)
```{r}
fit = glm(lslpts ~ slope + cplan + cprof + elev + log10_carea,
          family = binomial(), data = landslides)
```

And next we can use the `terra::predict()` function to apply the model to our terrain data.

```{r}
pred = predict(terrain, model = fit, type = "response")
```

```{r}
#| code-fold: true
tm_shape(pred) +
  tm_raster(
    col.scale = tm_scale_continuous(midpoint = NA, values = "-viridis"),
    col.legend = tm_legend(
      title = "",
      position = tm_pos_in("left", "bottom"),
      width = 10,
      frame = FALSE,
      orientation = "landscape"
    )
  ) +
  tm_title("Landslide susceptibility")
```

::: {.callout-tip}
# Statistical learning
![](https://r.geocompx.org/images/cover.png){width=25} For the full example on landslide susceptibility, visit the [Statistical learning chapter](https://r.geocompx.org/spatial-cv.html) in Geocomputation with R.
:::

## Data cubes

Data cubes are data structures that have become popular to organise and analyse raster data in particular.
You may have heard of Earth observation (EO) data cubes. 
This are usually data structures that organise satellite imagery and other type of EO data in cubes with multiple dimensions, most specifically the x/y coordinates, time, and bands.


::: {.callout-tip}
# Data ubes
![](https://r-spatial.org/book/images/cover.jpg){width=25} Learn more about data cubes in the [Data cubes chapter](https://r-spatial.org/book/06-Cubes.html) in Spatial Data Science.
:::

### Satellite imagery

In R, the `stars` package is designed to handle spatiotemporal arrays. 
We take a look at their example data, a Landsat-7 scene, read into R using `stars::read_stars()`.

```{r}
tif = system.file("tif/L7_ETMs.tif", package = "stars")
l7 = read_stars(tif)
plot(l7, axes = TRUE)
```

The quick plot above automatically creates subplots of the third dimension of the data, which is the `band` dimension.
We can subset this dimension using the `[` operator.

```{r}
l7
l7[,,,3:4]
```

And we can create RGB plots with the plot method of stars using the `rgb` parameter to corresponding bands.

```{r}
#| layout-ncol: 2
#| fig-height: 7
plot(l7, rgb = c(3,2,1), reset = FALSE, main = "RGB")    # rgb
plot(l7, rgb = c(4,3,2), main = "False colour (NIR-R-G)") # false colour
```

### Applying functions

We can also apply functions over dimensions. 
For example, here we create a function to calculate the NDVI.
This function takes two arguments, the red and nir bands.
We then subset the cube with dimensions `3:4`, followed by the dimensions on which this function is applied to and finally the function itself.

```{r}
fn_ndvi = function(red,nir) (nir-red)/(nir+red)
ndvi = st_apply(l7[,,,3:4], 1:2, fn_ndvi)
```

Let's take a look at the result with `tmap`.

```{r}
tm_shape(ndvi) +
  tm_raster(
    col.scale = tm_scale_continuous(
      values = "prgn",
      midpoint = 0
    )
  )
```

### Climate data

```{r}
precipitation = system.file("nc/test_stageiv_xyt.nc", package = "stars") |>
    read_stars()
precipitation
```

```{r}
nc = system.file("gpkg/nc.gpkg", package = "sf") |> 
  read_sf() |> 
  st_transform(st_crs(precipitation))
```

```{r}
nc_outline = nc |> 
  st_geometry() |> 
  st_union()
```

```{r}
#| fig-width: 10
#| fig-height: 7
ggplot() +
  geom_stars(data = precipitation[,,,1:12]) +
  scale_fill_viridis_c("Precipitation") +
  geom_sf(data = nc_outline, fill = NA, color = "red") +
  facet_wrap("time", ncol = 4) +
  theme_bw() +
  theme(legend.position = "bottom")
```

### Time series and aggregations

```{r}
precipitation_nc = aggregate(precipitation, by = nc, FUN = max)
```

```{r}
#| fig-width: 8
#| fig-height: 7
plot(precipitation_nc, max.plot = 23, border = "grey", 
     lwd = 0.5, mfrow = c(5,5))
```

```{r}
#| code-fold: true
#| fig-width: 10
#| fig-height: 9
#| warning: false
precipitation_nc |> st_as_sf(long = TRUE) |>
  st_join(nc) |> 
  ggplot() + 
  aes(
    x = as.POSIXct(time),
    y = test_stageiv_xyt.nc
  ) + 
  geom_point() + geom_line() +
  scale_x_datetime(date_breaks = "12 hours", date_labels = "%H:%M") +
  theme(legend.position = "none") +
  labs(x = "Time", y = "Precipitation (mm)") +
  facet_wrap(~NAME)
```

```{r}
index_max = function(x) ifelse(all(is.na(x)), NA, which.max(x))
precipitation_max = st_apply(precipitation_nc, "geom", index_max)
```

```{r}
precipitation_max$when = st_get_dimension_values(
  precipitation_nc, "time")[precipitation_max$index_max]
```

```{r}
#| fig-width: 10
#| fig-height: 5
plot(precipitation_max["when"], key.pos = 1, 
     main = "time of maximum precipitation")
```

```{r}
#| include: false
# automatically create a bib database for R packages
knitr::write_bib(c(.packages()), "packages-raster.bib")
```
